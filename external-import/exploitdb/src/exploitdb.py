# coding: utf-8

import os
import time
from datetime import datetime
import requests
from bs4 import BeautifulSoup
from random import randint
import re
import json
import base64

import certifi
import yaml
from exploitdbtostix2 import convert
from pycti import OpenCTIConnectorHelper, OpenCTIApiWork, get_config_variable


class ExploitDb:

    URL_basis = "https://www.exploit-db.com/exploits/"
    URL_raw_basis = "https://www.exploit-db.com/raw/"
    headers = {'User-Agent': 'Mozilla/5.0'}

    def __init__(self):
        # Instantiate the connector helper from config
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        self.helper = OpenCTIConnectorHelper(config)
        self.worker = OpenCTIApiWork(self.helper.api)
        # Extra config
        self.exploitdb_interval = get_config_variable(
            "EXPLOITDB_INTERVAL", ["exploitdb", "interval"], config, True
        )
        self.update_existing_data = get_config_variable(
            "CONNECTOR_UPDATE_EXISTING_DATA",
            ["connector", "update_existing_data"],
            config,
        )
        self.confidence_level = get_config_variable(
            "CONNECTOR_CONFIDENCE_LEVEL",
            ["connector", "confidence_level"],
            config,
        )
        self.label_color = get_config_variable(
            "CONNECTOR_LABEL_COLOR",
            ["connector", "label_color"],
            config,
        )
        self.history_ids = get_config_variable(
            "HISTORY_IDS",
            ["exploitdb", "history_ids"],
            config,
        )

    def get_interval(self):
        return int(self.exploitdb_interval) * 60 * 60 * 24

    def delete_files(self):
        if os.path.exists("exploitdb.json"):
            os.remove("exploitdb.json")
        if os.path.exists("data-stix2.json"):
            os.remove("data-stix2.json")

    def add_meta(self, list_added_exploit):
        # Get all the exploits
        req_list_malware = list_added_exploit
        # Assign data to exploit
        for item in req_list_malware:
            try:
                if("ExploitDB" in item["description"]):
                    # Confidence
                    self.helper.api.stix_domain_object.update_field(
                        id=item[0], input={"key": "confidence", "value": str(self.confidence_level)}
                    )
                    # Label
                    new_label_source = self.helper.api.label.create(
                                value="Exploit-DB", color=self.label_color
                    )
                    self.helper.api.stix_domain_object.add_label(
                                id=item[0], label_id=new_label_source["id"]
                    )
                    # Correlated with a CVE
                    if(item[1] != ""):
                        # Label
                        new_label_cve = self.helper.api.label.create(
                                    value=item[1], color=self.label_color
                        )
                        self.helper.api.stix_domain_object.add_label(
                                    id=item[0], label_id=new_label_cve["id"]
                        )
                        # Create the relationship between the vendor and the infrastructure
                        req_cve = self.helper.api.vulnerability.read(filters=[{"key": "name", "values": [item[1]]}])
                        if req_cve is not None:
                            self.helper.api.stix_core_relationship.create(
                                fromId=item[0],
                                toId=req_cve["id"],
                                relationship_type="exploits",
                                description=item[0] + " exploits the vulnerability " + item[1],
                                confidence=int(self.confidence_level),
                                update=True,
                            )
            except Exception as e:
                self.helper.log_info("Error with " + item[0] + " : " + str(e))
                pass

    def fetch_and_write(self, i):
        self.helper.log_info("Fetching of the ExploitDB " + str(i) + " done")
        page = requests.get(self.URL_basis + str(i), headers=self.headers)
        soup = BeautifulSoup(page.content, "html.parser")
        try:
            if(soup.find("h1", class_="card-title").getText().strip() == "404"):
                return "NOK"
            else:
                with open('exploitdb.json','a') as f:
                    f.write("\t{\n")
                    list_h6 = soup.find_all("h6", class_="stats-title", text=True)
                    f.write('\t\t' + '"edb-id": "' + list_h6[0].text.strip() + '",\n')
                    title = soup.find("h1", class_="card-title text-secondary text-center", text=True).text.strip()
                    title = title.replace('\\','/')
                    title = title.replace('\"','\'')
                    f.write('\t\t' + '"title": "' + title + '",\n')
                    f.write('\t\t' + '"publication-date": "' + list_h6[-1].text.strip() + '",\n')
                    req = soup.find("a", href = re.compile(r'https://nvd.nist.gov*'))
                    if(req == None):
                        f.write('\t\t' + '"cve": "",\n')
                    else:
                        f.write('\t\t' + '"cve": "CVE-' + req.getText().strip() + '",\n')
                    author_name = soup.find("a", href = re.compile(r'/?author=*')).getText().strip()
                    author_name = author_name.replace('\\','/')
                    author_name = author_name.replace('\"','\'')
                    f.write('\t\t' + '"author": "' + str(author_name) + '",' + '\n')
                    type_name = soup.find("a", href = re.compile(r'/?type=*')).getText().strip()
                    f.write('\t\t' + '"type": "' + str(type_name) + '",' + '\n')
                    platform = soup.find("a", href = re.compile(r'/?platform=*')).getText().strip()
                    f.write('\t\t' + '"platform": "' + str(platform) + '",' + '\n')
                    if(soup.find("i", style = re.compile(r"color: #ec5e10")) == None):
                        f.write('\t\t' + '"verified": true,\n')
                    elif(soup.find("i", style = re.compile(r"color: #96b365")) == None):
                        f.write('\t\t' + '"verified": false,\n')
                    line = '"references":\n\t\t{'
                    f.write('\t\t' + line + '\n')
                    f.write('\t\t\t\t"url-description": "' + self.URL_basis + str(i) + '",\n')
                    f.write('\t\t\t\t"url-code-raw": "' + self.URL_raw_basis + str(i) + '"\n')
                    f.write("\t\t},\n")
                    f.write('\t\t' + '"edb_code": "' + str(self.extract_code(self.URL_raw_basis + str(i))) + '"' + '\n')
                    f.write("\t},\n")
                    f.close()
                return "OK"
        except Exception:
            return "NOK"

    def extract_code(self, url):
        response =  requests.get(url=url, headers=self.headers)
        response = response.text.encode('utf-8')
        base64_response = base64.b64encode(response)
        base64_response = base64_response.decode('utf-8')
        return base64_response

    def process_file(self):
        with open(os.path.dirname(os.path.abspath(__file__)) + '/exploitdb.json','r+') as f:
            lines = f.readlines()
            f.seek(0)
            f.truncate()
            for line in lines[:-1]:
                f.write(line)
            if(len(lines) > 1):
                f.write("\t}\n")
                f.write("]")
            f.close()

    def database(self, debut):
        dir = os.path.dirname(os.path.abspath(__file__))
        count_err = 0
        with open(dir + '/exploitdb.json', 'w') as f:
            f.write('[\n')
            f.close()
        i = debut
        while (count_err < 4):
            #print(i)
            res = self.fetch_and_write(i)
            i = i + 1
            if(res == "NOK"):
                count_err = count_err + 1 
            else:
                count_err = 0  
            time.sleep(randint(3,8))

    def fetch_and_send(self, work_id):
        try:
            last_index = self.helper.api.external_reference.list(customAttributes="""url""",filters=[{"key": "source_name", "values": "ExploitDB"}],orderBy="url",orderMode="desc",first=1)[0]['url'].split('/')[-1]
            # Remove files
            self.delete_files()
            self.helper.log_info("Start of data extraction...")
            dir = os.path.dirname(os.path.abspath(__file__))
            self.database(int(last_index)-int(self.history_ids))
            self.process_file()
            self.helper.log_info("Converting the file")
            list_added_exploit = convert("exploitdb.json", "data-stix2.json")
            with open("data-stix2.json") as stix_json:
                contents = stix_json.read()
                self.helper.send_stix2_bundle(
                    contents,
                    entities_types=self.helper.connect_scope,
                    update=self.update_existing_data,
                    work_id=work_id,
                )
            self.worker.wait_for_work_to_finish(work_id)
            self.delete_files()
            self.add_meta(list_added_exploit)
        except Exception as e:
            self.delete_files()
            self.helper.log_error(str(e))
            time.sleep(60)

    def process_data(self):
        try:
            # Get the current timestamp and check
            timestamp = int(time.time())
            current_state = self.helper.get_state()
            if current_state is not None and "last_run" in current_state:
                last_run = current_state["last_run"]
                self.helper.log_info(
                    "Connector last run: "
                    + datetime.utcfromtimestamp(last_run).strftime("%Y-%m-%d %H:%M:%S")
                )
            else:
                last_run = None
                self.helper.log_info("Connector has never run")
            # If the last_run is more than interval (in days)
            if last_run is None or (
                (timestamp - last_run) > ((int(self.exploitdb_interval) - 1) * 60 * 60 * 24)
            ):
                timestamp = int(time.time())
                now = datetime.utcfromtimestamp(timestamp)
                friendly_name = "ExploitDB run @ " + now.strftime("%Y-%m-%d %H:%M:%S")
                work_id = self.helper.api.work.initiate_work(
                    self.helper.connect_id, friendly_name
                )
                self.fetch_and_send(work_id)
               
                # Store the current timestamp as a last run
                self.helper.log_info(
                    "Connector successfully run, storing last_run as " + str(timestamp)
                )
                self.helper.set_state({"last_run": timestamp})
                message = (
                    "Last_run stored, next run in: "
                    + str(round(self.get_interval() / 60 / 60 / 24, 2))
                    + " days"
                )
                self.helper.api.work.to_processed(work_id, message)
                self.helper.log_info(message)
            else:
                new_interval = self.get_interval() - (timestamp - last_run)
                self.helper.log_info(
                    "Connector will not run, next run in: "
                    + str(round(new_interval / 60 / 60 / 24, 2))
                    + " days"
                )
        except (KeyboardInterrupt, SystemExit):
            self.helper.log_info("Connector stop")
            exit(0)
        except Exception as e:
            self.helper.log_error(str(e))

    def run(self):
        self.helper.log_info("Fetching ExploitDB knowledge...")
        if self.helper.get_run_and_terminate():
            self.process_data()
            self.helper.force_ping()
        else:
            while True:
                self.process_data()
                time.sleep(60)


if __name__ == "__main__":
    try:
        ExploitDbConnector = ExploitDb()
        ExploitDbConnector.run()
    except Exception as e:
        print(e)
        time.sleep(10)
        exit(0)
