# coding: utf-8

import os
import time
from datetime import datetime
import requests
import re
import json

import yaml
from exploits_github_stix import convert
from pycti import OpenCTIConnectorHelper, OpenCTIApiWork, get_config_variable


class ExploitsG:

    headers = {'User-Agent': 'Mozilla/5.0'}
    
    def __init__(self):
        # Instantiate the connector helper from config
        config_file_path = os.path.dirname(os.path.abspath(__file__)) + "/config.yml"
        config = (
            yaml.load(open(config_file_path), Loader=yaml.FullLoader)
            if os.path.isfile(config_file_path)
            else {}
        )
        self.helper = OpenCTIConnectorHelper(config)
        self.worker = OpenCTIApiWork(self.helper.api)
        # Extra config
        self.exploits_interval = get_config_variable(
            "EXPLOITS", ["exploits", "interval"], config, True
        )
        self.update_existing_data = get_config_variable(
            "CONNECTOR_UPDATE_EXISTING_DATA",
            ["connector", "update_existing_data"],
            config,
        )
        self.confidence_level = get_config_variable(
            "CONNECTOR_CONFIDENCE_LEVEL",
            ["connector", "confidence_level"],
            config,
        )
        self.label_color = get_config_variable(
            "CONNECTOR_LABEL_COLOR",
            ["connector", "label_color"],
            config,
        )

    def get_interval(self):
        return int(self.exploits_interval) * 60 * 60 

    def delete_files(self):
        if os.path.exists("data-stix2.json"):
            os.remove("data-stix2.json")
        if os.path.exists("cve.sqlite"):
            os.remove("cve.sqlite")
        if os.path.exists("cve_db.json"):
            os.remove("cve_db.json")
            

    def add_meta(self, list_added_exploit):
        # Get all the exploits
        req_list_malware = list_added_exploit
        # Assign data to exploit
        for item in req_list_malware:
            try:
                self.helper.api.stix_domain_object.update_field(
                    id=item[0], input={"key": "confidence", "value": str(self.confidence_level)}
                )
                # Label
                new_label_source = self.helper.api.label.create(
                            value="GitHub", color=self.label_color
                )
                self.helper.api.stix_domain_object.add_label(
                            id=item[0], label_id=new_label_source["id"]
                )
                # Correlated with a CVE
                if(item[1] != ""):
                    # Create the relationship between the vendor and the infrastructure
                    req_cve = self.helper.api.vulnerability.read(filters=[{"key": "name", "values": [item[1]]}])
                    if req_cve is not None:
                        self.helper.api.stix_core_relationship.create(
                            fromId=item[0],
                            toId=req_cve["id"],
                            relationship_type="exploits",
                            description=item[0] + " exploits the vulnerability " + item[1],
                            confidence=int(self.confidence_level),
                            update=True,
                        )
            except Exception as e:
                self.helper.log_info("Error with " + item[0] + " : " + str(e))
                pass

    def fetch_and_send(self, work_id):
        try:
            self.helper.log_info("Fetching of the Exploits on Github...")
            r = requests.get(url="https://github.com/p1ay8y3ar/cve_monitor/raw/master/cve.sqlite", headers=self.headers)
            open('cve.sqlite', 'wb').write(r.content)
            list_added_exploit = convert('cve.sqlite',"data-stix2.json")
            with open("data-stix2.json") as stix_json:
                    contents = stix_json.read()
                    self.helper.send_stix2_bundle(
                        contents,
                        entities_types=self.helper.connect_scope,
                        update=self.update_existing_data,
                        work_id=work_id,
                    )
            stix_json.close()
            self.worker.wait_for_work_to_finish(work_id)
            self.add_meta(list_added_exploit)
            self.delete_files()
        except Exception as e:
            self.delete_files()
            self.helper.log_error(str(e))
            time.sleep(60)


    def process_data(self):
        try:
            # Get the current timestamp and check
            timestamp = int(time.time())
            current_state = self.helper.get_state()
            if current_state is not None and "last_run" in current_state:
                last_run = current_state["last_run"]
                self.helper.log_info(
                    "Connector last run: "
                    + datetime.utcfromtimestamp(last_run).strftime("%Y-%m-%d %H:%M:%S")
                )
            else:
                last_run = None
                self.helper.log_info("Connector has never run")
            # If the last_run is more than interval (in hours)
            if last_run is None or (
                (timestamp - last_run) > ((int(self.exploits_interval) - 1) * 60 * 60)
            ):
                timestamp = int(time.time())
                now = datetime.utcfromtimestamp(timestamp)
                friendly_name = "Explois on GitHub run @ " + now.strftime("%Y-%m-%d %H:%M:%S")
                work_id = self.helper.api.work.initiate_work(
                    self.helper.connect_id, friendly_name
                )
                self.fetch_and_send(work_id)
               
                # Store the current timestamp as a last run
                self.helper.log_info(
                    "Connector successfully run, storing last_run as " + str(timestamp)
                )
                self.helper.set_state({"last_run": timestamp})
                message = (
                    "Last_run stored, next run in: "
                    + str(round(self.get_interval() / 60 / 60, 2))
                    + " hours"
                )
                self.helper.api.work.to_processed(work_id, message)
                self.helper.log_info(message)
            else:
                new_interval = self.get_interval() - (timestamp - last_run)
                self.helper.log_info(
                    "Connector will not run, next run in: "
                    + str(round(new_interval / 60 / 60, 2))
                    + " hours"
                )
        except (KeyboardInterrupt, SystemExit):
            self.helper.log_info("Connector stop")
            exit(0)
        except Exception as e:
            self.helper.log_error(str(e))

    def run(self):
        self.helper.log_info("Fetching Exploits on Github knowledge...")
        if self.helper.get_run_and_terminate():
            self.process_data()
            self.helper.force_ping()
        else:
            while True:
                self.process_data()
                time.sleep(60)


if __name__ == "__main__":
    try:
        ExploitsGConnector = ExploitsG()
        ExploitsGConnector.run()
    except Exception as e:
        print(e)
        time.sleep(10)
        exit(0)
